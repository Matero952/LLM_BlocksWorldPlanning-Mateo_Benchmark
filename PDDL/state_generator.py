from itertools import product

"""
This module provides functions to generate all possible states for a list of blocks,
where each block can be placed either on the table or on top of another block, with
the constraint that no two blocks can be on the same block simultaneously. It also
includes functionality to count the number of valid states for a given number of blocks
using integer partitions.
Functions:
    generate_block_states(blocks):
        Generates all possible states for a list of blocks.
    integer_partitions(n):
            n (int): The integer to partition.
        Yields:
            list: A list of integers summing up to n, in non-increasing order.
    count_valid_states(n):
        Count the number of valid states for n blocks using the derived formula.
            n (int): The number of blocks.
            int: The number of valid states.
Main Execution:
    If the module is run as the main program, it generates and prints all possible states
    for a predefined list of blocks and compares the number of valid states generated by
    the `generate_block_states` function with the count obtained from the `count_valid_states`
    function for block counts from 1 to 10.
"""

def generate_block_states(blocks):
    """
    Generates all possible states for a list of blocks, where each block can be
    placed either on the table or on top of another block, with the constraint that
    no two blocks can be on the same block simultaneously.

    Args:
        blocks (list): List of block identifiers (e.g., ['A', 'B', 'C']).

    Returns:
        list: A list of dictionaries representing all possible states.
    """
    states = []

    # Generate all possible placements: table or other blocks
    possible_placements = ['table'] + blocks

    # Generate all combinations of placements for each block
    all_combinations = product(possible_placements, repeat=len(blocks))

    for combination in all_combinations:
        state = {}
        valid = True
        table_support = set()

        for block, placement in zip(blocks, combination):
            # A block cannot be placed on itself
            if placement == block:
                valid = False
                break
            state[block] = placement
            if placement == 'table':
                table_support.add(block)

        if not valid:
            continue

        # Check that no two blocks are on the same non-table block
        # Extract all placements that are blocks (not 'table')
        non_table_placements = [p for p in state.values() if p != 'table']
        if len(non_table_placements) != len(set(non_table_placements)):
            # This means there's a duplicate placement, so at least two blocks
            # are on the same block
            valid = False

        if not valid:
            continue

        # Check for cycles and ensure at least one block is on the table
        if valid and table_support:
            for block in blocks:
                current = block
                visited = set()
                while current != 'table':
                    if current in visited or current not in state:
                        valid = False
                        break
                    visited.add(current)
                    current = state[current]
                if not valid:
                    break

        if valid and table_support:
            states.append(state)

    return states

from math import factorial
from collections import Counter

def integer_partitions(n):
    """
    Generate all integer partitions of n.
    Each partition is represented as a list of integers
    summing up to n, in non-increasing order.
    """
    # Base case
    if n == 0:
        yield []
        return
    
    # Recursive generation
    def generate_partitions(number, max_part):
        if number == 0:
            yield []
        else:
            for first_part in range(min(number, max_part), 0, -1):
                for rest in generate_partitions(number - first_part, first_part):
                    yield [first_part] + rest
    yield from generate_partitions(n, n)

def count_valid_states(n):
    """
    Count the number of valid states for n blocks using the derived formula:
    a_n = sum over partitions p of n: (n! / (product of factorials of multiplicities of part sizes))
    """
    if n == 0:
        return 1  # If zero blocks, only one "state": empty.
    
    n_factorial = factorial(n)
    total = 0
    for partition in integer_partitions(n):
        # Count multiplicities of each distinct part size
        counts = Counter(partition)
        
        # Compute denominator: product of factorials of multiplicities
        denom = 1
        for count in counts.values():
            denom *= factorial(count)
        
        total += n_factorial // denom
    
    return total


if __name__ == "__main__":
    blocks = ["red_block", "blue_block", "yellow_block"]
    states = generate_block_states(blocks)
    for i, state in enumerate(states):
        print(f"State {i + 1}: {state=}\n")
    
    #for i in range(1, 11):
    #    obn = count_valid_states(i)
    #    states = generate_block_states(list(range(i)))
    #    print(f"{i}:{len(states)}=={obn}")
